(in-package :postgres-json)

;;;; The DB backend creation functions, the implementation macros
;;;; (mostly Postmodern defprepare forms) and the interface macros
;;;; to create a model.

;;;; Special variables
(defparameter *model-export-list* '(insert update get delete keys)
  "The list of symbols to export from our model interface.")

;;; Now you can just rebind these and have the functions below use
;;; them nicely.  But of course you'd need to recompile this file in
;;; order for the macros to work.  Or we could hardcode the various
;;; values as keyword arguments to the macros below to allow easier
;;; user customization.  But that is for another time MacLeod.

(defvar *id* 'id
  "A symbol being the default name of the primary key column in
created PostgreSQL tables.")

(defvar *id-type* 'integer
  "A symbol being the default type of the primary key column in
created PostgreSQL tables.")

(defvar *jdoc* 'jdoc
  "A symbol being the default name of the JSON column in created
PostgreSQL tables.")

(defvar *jdoc-type* 'jsonb
  "A symbol being the default type of the JSON column in created
PostgreSQL tables.")

;;;; Backend

(defun create-base-table (name schema)
  "Create a PostgreSQL table called NAME in SCHEMA, both symbols.
This is the base table for the model.  Requires an active DB
connection."
  (run `(:create-table ,(qualified-name-string name schema)
         ((,*id*      :type ,*id-type*   :primary-key t)
          (valid-to   :type timestamptz :default (:type "infinity" timestamptz))
          (valid-from :type timestamptz :default (:transaction-timestamp))
          (,*jdoc*    :type ,*jdoc-type*)))))

(defun create-old-table (name schema)
  "Create a PostgreSQL table called NAME in SCHEMA, both symbols.
This is the 'old' table for the model, which will store non current
rows.  Requires an active DB connection."
  (run `(:create-table ,(qualified-name-string name schema)
         ((,*id*      :type ,*id-type*)
          (valid-to   :type timestamptz)
          (valid-from :type timestamptz)
          (,*jdoc*    :type ,*jdoc-type*))
         (:primary-key ,*id* valid-to))))

(defun create-gin-index (name table schema)
  "Create a PostgreSQL GIN index with NAME on a database table TABLE
in SCHEMA, all symbols.  Note that if you use *JDOC-TYPE* 'json when
creating the tables you cannot then create these indexes --- see the
PostgreSQL documentation.  In fact the option 'jsonb_path_ops' to the
GIN index may be desirable under some circumstances but I have not yet
twisted s-sql to generate such an index declaration (clearly we could
just use a string).  Requires an active DB connection."
  (run `(:create-index ,name :on ,(qualified-name-string table schema)
         :using gin :fields ,*jdoc*)))

;;;; Low level DB access via Postmodern

(defmacro defprepare-nextval-sequence$ (name schema package-name)
  "Define a Postmodern prepared query for fetching the next value from
sequence NAME in SCHEMA (both symbols) and intern in the package
designated by PACKAGE-NAME.  The of the prepared query is generated by
NEXTVAL-SEQUENCE-NAME."
  (let ((op-name (db-op-name "nextval" name schema package-name)))
    `(defprepare-model-op ,op-name (,package-name)
       (:select (:nextval ,(qualified-name-string name schema)))
       :single!)))

(defmacro defprepare-insert$ (model table)
  "Define the INSERT$ low level DB operation on TABLE, a form denoting
a PostgreSQL table in S-SQL.  The resulting function is interned in
the package denoted by MODEL, a symbol."
  `(defprepare-model-op insert$ (,model)
     (:insert-into ,table :set ',*id* '$1 ',*jdoc* '$2)))

(defmacro defprepare-insert-old$ (model table old-table)
  "Define the INSERT-OLD$ low level DB operation on TABLE using date
from OLD-TABLE, both forms for denoting PostgreSQL tables in S-SQL.
The resulting function is interned in the package denoted by MODEL, a
symbol."
  `(defprepare-model-op insert-old$ (,model)
     (:insert-into ,old-table
                   ;; Note the dependence on the column ordering of
                   ;; CREATE-OLD-TABLE since :insert-into will not let
                   ;; me explicitly specify column names...
                   (:select ',*id*
                            (:transaction-timestamp)
                            'valid-from
                            ',*jdoc*
                            :from ,table
                            :where (:= ',*id* '$1)))))

(defmacro defprepare-update$ (model table)
  "Define the UPDATE$ low level DB operation on TABLE,
a form denoting a PostgreSQL table in S-SQL.  The resulting function
is interned in the package denoted by MODEL, a symbol."
  `(defprepare-model-op update$ (,model)
     (:update ,table
      :set ',*jdoc* '$2 'valid-from (:transaction-timestamp)
      :where (:= ',*id* '$1))))

(defmacro defprepare-get$ (model table)
  "Define the GET$ low level DB operation on TABLE,
a form denoting a PostgreSQL table in S-SQL.  The resulting function
is interned in the package denoted by MODEL, a symbol."
  `(defprepare-model-op get$ (,model)
     (:select ',*jdoc* :from ,table :where (:= ',*id* '$1))
     :single!))

;; Really ? Probably need mapcar over from-json...
;; (defmacro defprepare-get-all$ (model table)
;;   `(defprepare-model-op get-all$ (,model)
;;      (:select ',*jdoc* :from ,table)
;;      :column))

(defmacro defprepare-delete$ (model table)
  "Define the DELETE$ low level DB operation on TABLE,
a form denoting a PostgreSQL table in S-SQL.  The resulting function
is interned in the package denoted by MODEL, a symbol."
  `(defprepare-model-op delete$ (,model)
     (:delete-from ,table :where (:= ',*id* '$1) :returning ',*id*)
     :single))

(defmacro defprepare-get-all-ids$ (model table)
  "Define the GET-ALL-IDS$ low level DB operation on TABLE,
a form denoting a PostgreSQL table in S-SQL.  The resulting function
is interned in the package denoted by MODEL, a symbol."
  `(defprepare-model-op get-all-ids$ (,model)
     (:select ',*id* :from ,table)
     :column))

;;;; User interface

(defmacro defun-insert (model &key next-id stash-id-fn
                                   (to-json-fn 'to-json))
  "Define the model operation INSERT to be exported from the package
MODEL, a symbol.  NEXT-ID may be a symbol for a function that will
return unique ids for use as primary keys in the base table.  It is
called _inside_ the transaction so may access the DB if required.  You
need not supply NEXT-ID if you intend to supply your own ids to INSERT
using USE-ID --- see INSERT, defined herein.  If STASH-ID-FN is a
symbol we FUNCALL it with two arguments: the value of the id to be
used for the DB insert and the lisp OBJECT supplied to INSERT.
TO-JSON-FN must be a symbol for a function of one argument to
serialize lisp objects to JSON strings."
  `(defun-model-op insert (,model) (object &optional use-id)
     "Insert lisp object OBJECT into PostgreSQL after JSON
serialization.  If USE-ID is supplied, use that as the primary
key for this object rather than the automatically generated one.
Return the ID."
     (with-transaction-type (read-committed-rw)
       (let* ((id (if use-id use-id (funcall ',next-id)))
              (object (if ,(null stash-id-fn)
                          object
                          (funcall ',stash-id-fn id object))))
         (insert$ id (funcall ',to-json-fn object))
         id))))

(defmacro defun-update (model &key (to-json-fn 'to-json))
  "Define the model operation UPDATE to be exported from the package
MODEL, a symbol.  TO-JSON-FN must be a symbol for a function of one
argument to serialize lisp objects to JSON strings."
  `(defun-model-op update (,model) (id object)
     "Update the current value of object with primary key ID to be the
JSON serialization of OBJECT.  Return ID."
     (log:debug "Attempt update of ~A" id)
     (with-retry-serialization-failure ("update")
       (with-transaction-type (repeatable-read-rw)
         (insert-old$ id)
         (update$ id (funcall ',to-json-fn object))
         id))))

(defmacro defun-get (model &key (from-json-fn 'from-json))
  "Define the model operation GET to be exported from the package
MODEL, a symbol.  FROM-JSON-FN must be symbol for a function of one
argument to parse a JSON string to a lisp object.  Make it #'identity
so no parse occurs and you will get the JSON string proper."
  `(defun-model-op get (,model) (id &key (from-json ',from-json-fn))
     "Lookup the object with primary key ID and return a parse of the
JSON string by the function designator FROM-JSON."
     (funcall from-json
              (with-transaction-type (read-committed-ro)
                (get$ id)))))

(defmacro defun-delete (model)
  "Define the model operation DELETE to be exported from the package
MODEL, a symbol."
  `(defun-model-op delete (,model) (id)
     "Delete the object with primary key ID.  Returns ID if
successful, NIL otherwise."
     (log:debug "Attempt delete of ~A" id)
     (with-retry-serialization-failure ("delete")
       (with-transaction-type (repeatable-read-rw)
         (insert-old$ id)
         (nth-value 0 (delete$ id))))))

(defmacro defun-keys (model)
  "Define the model operation KEYS to be exported from the package
MODEL, a symbol."
  `(defun-model-op keys (,model) ()
     "Returns two values: a list of all primary keys for this model
and the length of that list."
     (with-transaction-type (read-committed-ro)
       (get-all-ids$))))
